<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="hq5sRpd2t4HpGsWwIxrXzsnIb0QBcNnMpCt91cXxT7s"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"nemolaw.com",root:"/",scheme:"Mist",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"disqus",storage:!0,lazyload:!1,nav:null,activeClass:"disqus"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="以前我觉得像这种概念上的知识大概知道,然后需要的时候能搜索就好.现在认知改变了,基础知识能记忆的应该尽量装在自己脑海里.你在跟别人沟通的时候,这些可以是共识而不再需要花时间去解释,效率更高.同时要是没意识到这些细微的差别,在定位问题的时候你的解决问题能力其实是差了一级."><meta property="og:type" content="article"><meta property="og:title" content="Mysql 笔记：高性能 mysql 笔记 (上)"><meta property="og:url" content="https://nemolaw.com/2018/01/23/mysql_hignperformancemysql/index.html"><meta property="og:site_name" content="Nemo的轨迹"><meta property="og:description" content="以前我觉得像这种概念上的知识大概知道,然后需要的时候能搜索就好.现在认知改变了,基础知识能记忆的应该尽量装在自己脑海里.你在跟别人沟通的时候,这些可以是共识而不再需要花时间去解释,效率更高.同时要是没意识到这些细微的差别,在定位问题的时候你的解决问题能力其实是差了一级."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.amazonaws.com/nemolaw/mysql_server_struct.png"><meta property="og:image" content="https://s3.amazonaws.com/nemolaw/mysql_geli.png"><meta property="og:image" content="https://s3.amazonaws.com/nemolaw/mysql_lock.png"><meta property="og:image" content="https://s3.amazonaws.com/nemolaw/mysql_auto.png"><meta property="og:image" content="https://s3.amazonaws.com/nemolaw/mysql_index.png"><meta property="article:published_time" content="2018-01-23T13:11:02.000Z"><meta property="article:modified_time" content="2021-08-10T03:00:23.000Z"><meta property="article:author" content="NemoLaw"><meta property="article:tag" content="计算机科学与技术"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.amazonaws.com/nemolaw/mysql_server_struct.png"><link rel="canonical" href="https://nemolaw.com/2018/01/23/mysql_hignperformancemysql/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Mysql 笔记：高性能 mysql 笔记 (上) | Nemo的轨迹</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-131534564-2"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-131534564-2")</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="Nemo的轨迹" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Nemo的轨迹</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">work hard, be persistent, and good luck</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fas fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fas fa-address-card fa-fw"></i>关于我</a></li><li class="menu-item menu-item-sparethechild"><a href="/spare-the-child/" rel="section"><i class="fas fa-heart-broken fa-fw"></i>放过儿童项目</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://nemolaw.com/2018/01/23/mysql_hignperformancemysql/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/author.jpg"><meta itemprop="name" content="NemoLaw"><meta itemprop="description" content="但盼风雨来，能留你在此"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Nemo的轨迹"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Mysql 笔记：高性能 mysql 笔记 (上)</h1><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-01-23 21:11:02" itemprop="dateCreated datePublished" datetime="2018-01-23T21:11:02+08:00">2018-01-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-08-10 11:00:23" itemprop="dateModified" datetime="2021-08-10T11:00:23+08:00">2021-08-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ToolorToy/" itemprop="url" rel="index"><span itemprop="name">ToolorToy</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/2018/01/23/mysql_hignperformancemysql/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/23/mysql_hignperformancemysql/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span><div class="post-description">以前我觉得像这种概念上的知识大概知道,然后需要的时候能搜索就好.现在认知改变了,基础知识能记忆的应该尽量装在自己脑海里.你在跟别人沟通的时候,这些可以是共识而不再需要花时间去解释,效率更高.同时要是没意识到这些细微的差别,在定位问题的时候你的解决问题能力其实是差了一级.</div></header><div class="post-body" itemprop="articleBody"><ul><li>[第一章 mysql 架构和历史](# 第一章 - mysql - 架构和历史)<ul><li>[1.2 并发控制](#12 - 并发控制)<ul><li>[锁的种类](# 锁的种类)</li><li>[锁粒度](# 锁粒度)</li><li>[锁级别](# 锁级别)</li><li>[加锁的方式](# 加锁的方式)</li><li>[使用锁的方式](# 使用锁的方式)</li></ul></li><li>[1.3 事务](#13 - 事务)<ul><li>[隔离级别](# 隔离级别)</li><li>[死锁](# 死锁)</li><li>[事务日志](# 事务日志)</li><li>[mysql 中的事务](#mysql 中的事务)</li><li>[mysql 存储引擎](#mysql - 存储引擎)<ul><li><a href="#innodb">innodb</a></li><li><a href="#myisam">myisam</a></li><li><a href="#archive">Archive</a></li><li><a href="#memory">memory</a></li><li>[其他引擎](# 其他引擎)</li></ul></li></ul></li></ul></li><li>[第二章:mysql 基准测试](# 第二章 mysql - 基准测试)</li><li>[第三章：服务器性能分析](# 第三章 - 服务器性能分析)<ul><li>[入门](# 入门)</li><li>[一个诊断案例：在疯狂中找到条理](# 一个诊断案例在疯狂中找到条理)</li></ul></li><li>[第四章 Schema 与数据类型优化](# 第四章 - schema 与数据类型优化)<ul><li>[varchar 和 char](#varchar - 和 - char)</li><li>[使用 enum 存储字符串类型](# 使用 enum 存储字符串类型)</li><li><a href="#timestamp-and-datetime">timestamp and datetime</a></li><li><a href="#bit">bit</a></li><li>[最后：建议](# 最后 - 建议)</li></ul></li><li>[第五章：高性能的索引](# 第五章 - 高性能的索引)<ul><li>[索引的类型](# 索引的类型)</li><li>[还能优化的手段](# 还能优化的手段)</li></ul></li></ul><p>每一章其实都是很大的话题，所以我只是做一下摘要，至少让自己在概念上能过关。计划有上中下三篇.</p><h3 id="第一章-mysql-架构和历史"><a href="#第一章-mysql-架构和历史" class="headerlink" title="第一章 mysql 架构和历史"></a>第一章 mysql 架构和历史</h3><p>直接上图，别像我，研究那么久的 mysql , 连整体架构都不知道 ( ps,mysql 的源代码组织太差，是人读的么 )</p><p><img src="https://s3.amazonaws.com/nemolaw/mysql_server_struct.png" alt=""></p><h4 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h4><blockquote><p>控制并发的一种思路是用锁</p></blockquote><h5 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h5><ul><li>只读锁</li><li>只写锁</li><li>读写锁</li></ul><h5 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h5><p>表锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</p><p>页锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p><p>行锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高</p><p>MyISAM 和 MEMORY 存储引擎采用的是表级锁 (table-level locking);BDB 存储引擎采用的是页面锁 (page-level locking), 但也支持表级锁；InnoDB 存储引擎既支持行级锁 (row-level locking), 也支持表级锁，但默认情况下是采用行级锁.</p><h5 id="锁级别"><a href="#锁级别" class="headerlink" title="锁级别"></a>锁级别</h5><p>共享锁 (S)</p><p>排他锁 (X)</p><h5 id="加锁的方式"><a href="#加锁的方式" class="headerlink" title="加锁的方式"></a>加锁的方式</h5><p>自动锁</p><p>显示锁</p><h5 id="使用锁的方式"><a href="#使用锁的方式" class="headerlink" title="使用锁的方式"></a>使用锁的方式</h5><p>乐观锁</p><p>悲观锁</p><h4 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h4><h5 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h5><blockquote><p>在一个事务中 (可能有多个 update,select), 数据修改后，针对不同时刻的查询，这个修改是否应该体现。这带来了脏读现象。从而也使用了不同的隔离级别来避免</p></blockquote><p>推荐阅读：深入分析事务的隔离级别](<a href="http://www.hollischuang.com/archives/943" target="_blank" rel="noopener">http://www.hollischuang.com/archives/943</a>)</p><p>4 种隔离级别：未提交读；提交读；可重复读；可串行化；</p><ul><li><p>Read Uncommitted: 事务中的修改，即使没有提交，其他事务是可见的。一般不建议使用，在没有明显的好处下，带来了 dirty read (脏读)</p></li><li><p>Read Committed: 事务只能看见自己已经提交的事务所做的修改。对于这个事务来说是会产生脏读的 (两次同样的查询，会带来不一样的结果)</p></li><li><p>Repeatable Read: 保证了在一个事务中多次读取同样记录的结果是一致的。这理论上避免了脏读的现象。但无法避免另一个问题：幻读.(某个事务在读取某一个范围内的记录时，另一个事务又在该范围内插入了新的记录，当该事务再次执行相同的查询时，就会产生幻行)</p></li></ul><p>可重复读是 Mysql 默认的事务隔离级别.</p><ul><li>Serializale: 可串行化。最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读问题.</li></ul><p><img src="https://s3.amazonaws.com/nemolaw/mysql_geli.png" alt=""></p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>说一下，这里生成锁的原因不仅仅是时间凑巧，数据加载不是一条条的，磁盘是会预加载的，所以这里也有可能把锁加上导致死锁。有时候这才是分析的难点 (我没遇到过，这是大神的 PPT 说的)</p><p><img src="https://s3.amazonaws.com/nemolaw/mysql_lock.png" alt=""></p><h5 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h5><p>写数据更快：更新数据并不是将内存的拷贝值回写到数据本身硬盘所在的位置，而是追加到事务日志中 (使用磁盘一小块区域内的顺序 I/O), 随机 I/O 需要在磁盘的多个地方移动磁头.</p><p>事务日志持久后，内存中修改的数据在后台可以慢慢刷回到磁盘中去。所以修改数据需要些两次磁盘.</p><blockquote><p>这里可以体会一个思想，预写日志 ( Write####Ahead Logging). 当修改一次数据比较慢的时候，我们就找一个地方快速把我们的修改记录记下来.</p></blockquote><h5 id="mysql-中的事务"><a href="#mysql-中的事务" class="headerlink" title="mysql 中的事务"></a>mysql 中的事务</h5><p>mysql 提供了两种事务型的存储引擎: InnoDB 和 NDB Cluster.<br>mysql 默认采用自动提交 ( AutoCommit ) 模式，也就是说，如果不是显示地声明一个事务，每一个查询都被当做一个事物执行提交。可以通过以下命令来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;% autocomm%&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://s3.amazonaws.com/nemolaw/mysql_auto.png" alt=""></p><p>值得注意的点:</p><ul><li><p>autocommit = 0 , 当前所有查询都是在一个事务中，除非显示执行 commit</p></li><li><p>对于 MyIsam 这样存储引擎的表，由于没有事务的支持，可以把 autocommit 当做一直是 <em>ON</em> 的状态</p></li><li><p>Innodb 采用的是两阶段锁定协议 ( two-phase locking protocol ). 事务执行过程中，随时可以执行锁定，但锁只有在 commit 或者 rollback 的时候才会释放，并且该事物所有的锁是同一个时刻释放的.</p></li></ul><h5 id="mysql-存储引擎"><a href="#mysql-存储引擎" class="headerlink" title="mysql 存储引擎"></a>mysql 存储引擎</h5><p>对下面 sql 执行结果的理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show table status like &#39;% table_name%&#39;</span><br></pre></td></tr></table></figure><p>有点 sql 基础都能理解的几个字段：表名 ( name ); 使用的存储引擎 ( MyIsam ); 创建时间；更新时间；表注释 (comment); 下面详细说一下其它字段的意义 (感觉我这个笔记其实变成一个简短的手册了)</p><ul><li><p>row__format: dynamic (行的长度是不确定的，例如包含了 varchar,blob 这样类型的字段。这里可以了解一下 varchar,char,text 之间的区别),fixed (行的长度是可以确定的),compressed (这个类型只存在在压缩表里面) Compact ()</p></li><li><p>rows: 这个好理解，行数。但小心，在 InnoDB 里面这个值是估计值，在 MyIsam 是准确值 ( MyIsam 数据文件，索引，表结构是独立分开的，表的信息，如总行数是可以不通过 count (1) 得出 )</p></li><li><p>avg__row__length: 平均每一行的字节数，可以 除以 1024 的平方转为 MB</p></li><li><p>data_length: 表数据大小，字节为单位</p></li><li><p>max_data_length: 表的最大存储容量，这跟存储引擎有关 为什么 innodb 这里显示 0,myisam ???</p></li><li><p>index_length: 索引的大小</p></li><li><p>data_free: 对于 myisam, 表示已经分配但没有使用的空间，包括删除的行，后续可以被 insert 的空间</p></li><li><p>auto_increment: 建表的时候，可以设置某个字段为自增 (常常为主键) 这里记录的是当前自增的最大值。我们可以研究一下这里生成的方式：当需要的时候，获取到表中 key 的最大值，加一。之后这个值是常驻在内存中，方便下一次获取.</p></li><li><p>check_time:</p></li><li><p>collation: 建表默认字符集和字符列排序规则</p></li><li><p>checksum: 启用的话，保存的是整个表的实时校验和</p></li><li><p>createoption: 建表的时的其它选项</p></li></ul><h6 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h6><p>InnoDB 使用 MVCC 来支持高并发，并且支持 4 种标准的隔离方式，默认是 Repeatable Read, 并且通过间隙锁 (next_key locking) 策略来防止幻读的出现。间隙锁使得 Innodb 不仅仅是锁定涉及查询的行，还会对索引中的间隙行进行锁定，以防止幻行的插入 ( 原来如此，这就能解释了 )</p><p>InnoDB 内部做的优化点：(感觉这些也是坑存在的原因呀) 列一下，感觉都可以当做一个话题来聊一聊:</p><ul><li>基于聚簇索引建立的 (它使得对主键的查询有很高的效率，但二级索引就需要带上主键)</li><li>从磁盘读取的时候采用了预测读</li><li>在内存中建立 hash 索引以加速读操作的自适应哈希索引 (adaptive hash index ) , 以及能够加速插入操作的插入缓存 ( insert buffer ) — 这一段话就够我们受的了…..</li></ul><h6 id="myisam"><a href="#myisam" class="headerlink" title="myisam"></a>myisam</h6><p>特性关键词：全文检索，压缩，空间函数 ( GIS ), 不支持事物和行级锁，崩溃后是无法恢复的。三个文件 (表结构，表数据 myd, 表索引 myi)</p><ul><li><p>加锁：表锁，读取的时候共享锁，写入的时候，排它锁</p></li><li><p>修复：修复不等同于奔溃后恢复。修复会使得一些数据丢失.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check table t_name;</span><br><span class="line">repair table t_name ;</span><br><span class="line"> 检查和修复完之后可以在看到 check_time 的更新 </span><br><span class="line">show table status like &#39;% t_name%&#39;;</span><br></pre></td></tr></table></figure></li><li><p>索引：对 BLOB 和 TEXT , 可以基于前 500 个字符创建索引；myisam 的全文索引是基于分词.</p></li><li><p>性能：延迟更新索引键 ( DELAY_KEY_WRITE ) 不立即把修改的索引写入磁盘；性能的瓶颈几乎是出在表锁上.</p></li><li><p>压缩表：压缩表适合做仓库存储，修改一条数据经过解压 – 修改 – 压缩储存；这对变化频繁的数据是不利的.</p></li></ul><h6 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h6><p>只支持 insert 和 select , 利用 zlib 对插入行进行压缩，io 会比 mysiam 更少。但每一次 select 需要扫描全表.Archive 适合日志和数据采集类的应用.</p><h6 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h6><p>需要快速访问，数据不会被修改，重启后丢失也无所谓。那就使用 memory 引擎，数据是全部加载到内存的.]</p><h6 id="其他引擎"><a href="#其他引擎" class="headerlink" title="其他引擎"></a>其他引擎</h6><p>基本没用过: blackhole ; csv ; federated ;merge ; NDB 集群引擎</p><p>merge 表是一类 myisam 表的聚集。表结构一模一样. merge 的好处是对外提供了一个统一视图，让别人以为只有一张表。这是我的理解.</p><h3 id="第二章-mysql-基准测试"><a href="#第二章-mysql-基准测试" class="headerlink" title="第二章:mysql 基准测试"></a>第二章:mysql 基准测试</h3><p>首先明确测试啥：怎么衡量你的性能？需要的指标是什么？指标的基准又是什么</p><h3 id="第三章：服务器性能分析"><a href="#第三章：服务器性能分析" class="headerlink" title="第三章：服务器性能分析"></a>第三章：服务器性能分析</h3><p>首先判断到底是服务器的问题，还是 mysql 的问题，然后再定位是不是某一条 sql 引起的.</p><blockquote><p>这是我之前的一种思维误区吧，我一来就是先分析 sql. 这也是没有整体把握的体现</p></blockquote><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>分析慢查询日志: (my.cnf 里面可以设置当一个查询超过多少时间的时候，就会被记录下来。这样方便做性能优化) 作者建议使用 pt-query-digest 自顶向下的分析方法，先得到一个整体的分析报告。而不是一来就打开整个慢查询日志开始干 (好吧，我的确是这样的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;slow_query_log&#39;;</span><br><span class="line">show variables like &#39;long_query_time&#39;;</span><br><span class="line"></span><br><span class="line">set global slow_query_log&#x3D;1; # 这个只对当前数据库生效 (对当前 session, 建议退出重新登录 ), 重启 mysql 就失效了。永久生效的方式是修改配置文件 my.cnf .</span><br><span class="line">slow_query_log &#x3D;1</span><br><span class="line">set global long_query_time&#x3D;3;</span><br><span class="line">slow_query_log_file&#x3D;&#x2F;tmp&#x2F;mysql_slow.log 默认是放在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</span><br><span class="line">long_query_time 默认查询超过 10s 会记录下来，可以在 my.cnf 修改。刚好等于 10s 是不会记录下来的.</span><br><span class="line"></span><br><span class="line"> 然后可以通过命令 select sleep (5) 看看慢查询日志长什么样 </span><br><span class="line"></span><br><span class="line"># User@Host: root [root] @ localhost []</span><br><span class="line"># Thread_id: 49 Schema: QC_hit: No</span><br><span class="line"># Query_time: 5.003580 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0</span><br><span class="line">SET timestamp&#x3D;1515237341;</span><br><span class="line">select sleep (5);</span><br></pre></td></tr></table></figure><p>有了慢查询日志的概念之后，我们学习一下 mysqldumpslow 这个工具的使用，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c 访问计数 </span><br><span class="line">-t top 的意思 </span><br><span class="line">-g 可以是用正则过滤 </span><br><span class="line">-r 返回记录 </span><br><span class="line">-l 锁定的时间 </span><br><span class="line">mysqldumpslow -s c -t 10 slow.log | less # 日志中记录最多的 10 个 sql</span><br></pre></td></tr></table></figure><p>使用第三方工具:</p><blockquote><p>总是有更好的工具让你更快定位到问题.</p></blockquote><ul><li>pt-query-digest: 一个 perl 脚本，可以对整个慢查询 log 输出一个统计报告: pt-query-digest slow_query_log.log</li></ul><p>到了这一步，定位到是单条查询的问题，这时候才是想办法优化 sql.( 好吧，我之前的文章一来就是在优化 sql, 现在在大神的上帝视角来看，我这是小毛孩 )</p><p>sql 的优化手段有：使用 explain 查看 sql 的执行情况，主要关注命中的索引；开启 profiles 查看 sql 消耗的资源.</p><ul><li><p>explain</p><ol><li>type: 命中索引类型。结果好到坏 – range (常数值的范围，索引范围扫描) &gt; index (索引全扫描) &gt; ALL (全表扫描). 一般查询应到达 range 级别</li><li>rows: sql 执行检查的记录数<br>主要关注这两点，其他可以查资料了解</li></ol></li><li><p>profiles</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; set profiling&#x3D;1; (默认没开启)</span><br><span class="line">&gt; your sql ;</span><br><span class="line">&gt; show profiles;</span><br></pre></td></tr></table></figure><p>SQL 层面已经优化不动，这时候我的建议：从客户端请求到最后获取数据，每一个链路都梳理一遍。性能肯定有办法提升。例如</p><ul><li><p>Client 是否可以在本地加 cache?</p></li><li><p>Client 到 Server 的连接 (长连接短连接了解下，连接池了解下)</p></li><li><p>Server 端：分库分表，使用主从 (分离读写), 冷热隔离</p></li><li><p>以上试过还有问题，这样的业务量，国内第一梯队的互联网公司了吧。考虑招一个架构师吧</p></li></ul><h4 id="一个诊断案例：在疯狂中找到条理"><a href="#一个诊断案例：在疯狂中找到条理" class="headerlink" title="一个诊断案例：在疯狂中找到条理"></a>一个诊断案例：在疯狂中找到条理</h4><blockquote><p>在大量的输出中快速找到问题可能发生的地方<br>这种需要线上处理经验的，我实在很好奇在这里纸上谈兵的作用。能不能把 DBA 聚集起来，模拟线上问题发生，新手可以在上面学习.leecode 是考你基本能力，这个平台的目标是靠你工程的能力。可以想一想。其实大数据处理也一样，大公司现在的做法是每周期的线上比赛.</p></blockquote><p>服务器基本的状态：多少 cpu, 核心，操作系统版本，数据库版本，磁盘使用情况，io 情况，数据库数据量，</p><p>too mamy connection : 我的第一反应是调高默认配置的连接数，囧…..</p><h3 id="第四章-Schema-与数据类型优化"><a href="#第四章-Schema-与数据类型优化" class="headerlink" title="第四章 Schema 与数据类型优化"></a>第四章 Schema 与数据类型优化</h3><p>建议:</p><ul><li>最小原则：在确定情况下，越小的类型说明占用磁盘越少，读取越快</li><li>简单：整形比字符操作代价更低 (用内建类型存储时间和用整形存储 ip)</li><li>避免 NULL: 当可为 NULL 的字段作为索引，会多占一个字节的空间，同时在 myisam, 可能是一个固定长度的 int 变成可变长度的索引。也有例外，innodb 使用单独的位 bit 储存，这对于稀疏矩阵是有很好的空间效率的。但这点不适用与 Myisam.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timestamp 和 datetime 都可以表示到秒的时间，但 timestamp 存储空间少一半，并且会根据时区改变，具有自动更新的能力，容易，timestamp 能表示的时间范围会小一些.</span><br><span class="line"></span><br><span class="line">timestamp 4 个字节，时间在 1970 到 2037 之间可以为空，但不允许自定义值。以 UTC 格式保存 </span><br><span class="line"></span><br><span class="line">datetime 8 个字节，可以 null, 可以自定义，系统不会修改其值。与时区无关.</span><br></pre></td></tr></table></figure><p>int (11) 里面 11 的意思是 ‘ 限制显示时候的宽度 ‘, 并不是限制 int 的大小.<br>尽量存储整形，然后了根据业务进行转换.</p><h4 id="varchar-和-char"><a href="#varchar-和-char" class="headerlink" title="varchar 和 char"></a>varchar 和 char</h4><p>varchar 是按需存储，也就是说它存储的是可变字符串.(但是当你指定 row_format=fixed 的时候，varchar 就变成了定长存储)<br>一个 varchar (10) 需要 11 个字节的存储空间，varchar (1000) 则需要 1002 个字节，其中 2 个字节是用来存储列的长度<br>varchar 是变长的，可以提高存储性能；但 update 的时候，</p><blockquote><p>要是行可能比原来的更长，这会导致做额外的工作：如果一个行占用的空间增加，并且页内没有足够的空间可以存储，这种情况下，不同的存储引擎处理方式是不一样的，myisam 会将行拆成不同的片段存储，innodb 则需要分裂页来使行可以放进页内。其他的存储引擎也许从不在原数据位置更新数据.</p></blockquote><p>使用 varchar 的情况：字符串列最长长度比平均长度大很多；列更新比较少，(所以碎片不是问题); 使用了像 uft-8 这样复杂的字符集，每一个字符都使用不同的字节数进行存储.</p><p>在 5.0 版本后，mysql 在存储和检索时会保留末尾的空格，但 4.1 之前是剔除的. innodb 更灵活，它会把过长的 varchar 存储为 blob?</p><p>char: 定长；存储 char 类型时，mysql 会提出所有末尾空格. char 在比较的时候会采取填充空格的方式以方便进行比较.<br>char 适合存储短字符，或者所有值的长度很接近。例如，存储 md5 值。对于定长的字符更不容易产生碎片。对于非常短的列，char 比 varchar 更有效率。例如存储 Y 或者 N, char (1) 需要一个字节，varchar (1) 需要两个.<br>eg: 同样都是 char (10) , ‘aa’, ‘ aa’, ‘aa ‘ 是不一样的.’aa ‘ 末尾的空格会被截断.</p><p>memory 引擎只支持定长的行，有可变长字段也会根据最大长度分配最大空间。不过，填充和截取空格的行为是在 mysql 服务层操作的，对存储层透明.<br>同理还有 binary 和 varbinary 的区别。它们存储的是二进制字符串 (存储的是字节码). 字节码比较会更快.</p><p>对于 BLOB 和 TEXT , mysql 经常是当做一个对象来处理 (存储在一个外部存储区域来存储), 使用一个指针 (1~4 个字节) 指向它们实际的存储的值. BLOB 存储的是二进制数据，没有排序规则或字符集. TEXT 有。在进行排序的时候，TEXT 实际会比较的字符长度在 max_sort_length.memory 引擎不支持 BLOB 和 TEXT .</p><h4 id="使用-enum-存储字符串类型"><a href="#使用-enum-存储字符串类型" class="headerlink" title="使用 enum 存储字符串类型"></a>使用 enum 存储字符串类型</h4><blockquote><p>create table enum_test (e enum (‘aa’,’bb’,’cc’) not null) ;</p></blockquote><p>mysql 存储的时候实际上是把变量 e 存储为整形，(只占 1~2 个字节) . 在 .frm 文件中存储 数字 – 字符串 的映射关系的存储表。会导致疑惑的地方就是你在 order by e 的时候，不是按字母，是按枚举值</p><h4 id="timestamp-and-datetime"><a href="#timestamp-and-datetime" class="headerlink" title="timestamp and datetime"></a>timestamp and datetime</h4><p>datetime 精度到秒，与时区无关。使用 8 个字节存储，表示范围是 1001 年到 99999 年. timestamp ( 默认建议) 保存了自 1970 年 1 月 1 日以来的秒数，所以它只需要 4 个字节的存储时间 (1970~2038).timestamp 有时区的概念，不同时区 (有时候是主机的时间) 存储的值不一样.</p><h4 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h4><p>底层来看，bit 是一个字符串类型。不同的存储殷勤对 bit 的存储是不一样的 ( myiasm 17 个 bit 为了节省空间，使用 3 个字节解决。但 memory 和 innnodb 则是一个 bit 一个整形，不节省空间.)</p><p>现在用来越觉得 mysql 难的原因在于他就像一个城邦，缺乏内部的一致性。导致需要一个高级 DBA 来处理。这样的数据库还能流行？</p><h4 id="最后：建议"><a href="#最后：建议" class="headerlink" title="最后：建议"></a>最后：建议</h4><ul><li>尽可能用整形，并且加上自增</li><li>使用 enum 作为固定长度的标识行是可行的，但大部分情况最好避免</li><li>避免字符串。一来消耗空间，同时在 myisam 上使用字符串作为标示行要小心，myiasm 会对字符串进行压缩索引，这会导致查询变慢. (我简单的查询，500 次性能反而是用 set 的好一点点.)</li><li>混用范式化和反范式化：背景就不说了，最常见的反范式化数据的方法是复制或者缓存.(在不同的表里面存储相同的列，使用触发器更新缓存值.)</li><li>alter table 很耗性能，最差的是整张表重建.</li></ul><h3 id="第五章：高性能的索引"><a href="#第五章：高性能的索引" class="headerlink" title="第五章：高性能的索引"></a>第五章：高性能的索引</h3><p>索引的目的:</p><ul><li>减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将随机 io 变成顺序 io</li></ul><p><a href="https://book.douban.com/subject/2410000/" target="_blank" rel="noopener">推荐：Relational Database Index Design and the Optimizers</a></p><p>索引并不总是有效的：小表，简单的扫描全表更高效；中大型表，索引是有效的，特大型表，建立和使用索引的代价随之增长.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 下面是无法使用索引的，但只要一个简单的变换就可以。体会这里面的区别 </span><br><span class="line"></span><br><span class="line">select * from table where id + 1 &#x3D; 5 ;</span><br><span class="line">select * from table where to_days (current_date) - to_days (date_col) &lt;&#x3D; 10 ; </span><br><span class="line">select * from table where id &#x3D; 1 or cnt_id &#x3D; 3 (建议使用 union all ) 在早版本的 4.1 mysql 是无法使用索引的，后面引入了 索引合并 </span><br></pre></td></tr></table></figure><h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><ol><li>B-tree 索引</li></ol><p>最左匹配原则</p><ol start="2"><li>哈希索引</li></ol><p>在 memory 引擎下工作 (该引擎也可以使用 B-tree)</p><ol start="3"><li><p>空间索引 (R-Tree)</p></li><li><p>全文索引</p></li><li><p>聚簇索引</p></li></ol><p>这不是一种索引类型，只是一种数据存储方式。细节依赖于具体实现. Innodb 的聚簇索引是在同一个结构中保存了 B-Tree 索引和数据行.(通过主键聚集数据)</p><blockquote><p>看完这一段，聚集索引和 B+tree 到底什么关系，恍然大悟.</p></blockquote><h4 id="还能优化的手段"><a href="#还能优化的手段" class="headerlink" title="还能优化的手段"></a>还能优化的手段</h4><ul><li>索引的选择性</li></ul><p>前缀索引：优化的是索引本身的大小</p><p>对于占用空间较多的字符串，全部作为索引是不划算的。所以有人提出了一种思想：那我们就用部分字符串当做索引不就好了，例如字段的前 4 个字符。但仔细想，这会带来什么问题呢？要是有个字段，命名方式是 ‘nemo’ + 自定义部分，你会发现这时候索引就是无效的，每一个都是以 nemo 为索引。所以有人提出了 Cardinality 的概念。去字段前 4 个字符为例，具体计算如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select count (distinct left (字段名，4) )&#x2F; count (1) from table</span><br></pre></td></tr></table></figure><p>该值越大 (值的差异越大), 说明分散效果越好，说明越适合当索引。可以适当调整要取的字符数，怎么调，根据实际的数据和经验调</p><p>缺点：是无法使用前缀索引做 order by 和 group by ,mysql 也无法利用前缀索引做覆盖扫描.</p><ul><li>联合索引</li></ul><p><img src="https://s3.amazonaws.com/nemolaw/mysql_index.png" alt=""></p><p>** 第五章索引未完，待续…**</p></div><div class="reward-container"><div>欢迎用Dogecoin支持我不断记录</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>支持</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/nemo-dogecoin-address.png" alt="NemoLaw Dogecoin"><p>Dogecoin</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/" rel="tag"><i class="fa fa-tag"></i> 计算机科学与技术</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2018/01/22/trendandfuture/" rel="prev" title="未来世界"><i class="fa fa-chevron-left"></i> 未来世界</a></div><div class="post-nav-item"><a href="/2018/02/04/sst_basic_skill_intro/" rel="next" title="安全技能树简版 - 基础必备 (一)">安全技能树简版 - 基础必备 (一) <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-mysql-架构和历史"><span class="nav-number">1.</span> <span class="nav-text">第一章 mysql 架构和历史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-并发控制"><span class="nav-number">1.1.</span> <span class="nav-text">1.2 并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#锁的种类"><span class="nav-number">1.1.1.</span> <span class="nav-text">锁的种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁粒度"><span class="nav-number">1.1.2.</span> <span class="nav-text">锁粒度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁级别"><span class="nav-number">1.1.3.</span> <span class="nav-text">锁级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加锁的方式"><span class="nav-number">1.1.4.</span> <span class="nav-text">加锁的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用锁的方式"><span class="nav-number">1.1.5.</span> <span class="nav-text">使用锁的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-事务"><span class="nav-number">1.2.</span> <span class="nav-text">1.3 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#隔离级别"><span class="nav-number">1.2.1.</span> <span class="nav-text">隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#死锁"><span class="nav-number">1.2.2.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事务日志"><span class="nav-number">1.2.3.</span> <span class="nav-text">事务日志</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-中的事务"><span class="nav-number">1.2.4.</span> <span class="nav-text">mysql 中的事务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-存储引擎"><span class="nav-number">1.2.5.</span> <span class="nav-text">mysql 存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#innodb"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">innodb</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#myisam"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">myisam</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Archive"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">Archive</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#memory"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">memory</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#其他引擎"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">其他引擎</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章-mysql-基准测试"><span class="nav-number">2.</span> <span class="nav-text">第二章:mysql 基准测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章：服务器性能分析"><span class="nav-number">3.</span> <span class="nav-text">第三章：服务器性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入门"><span class="nav-number">3.1.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个诊断案例：在疯狂中找到条理"><span class="nav-number">3.2.</span> <span class="nav-text">一个诊断案例：在疯狂中找到条理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章-Schema-与数据类型优化"><span class="nav-number">4.</span> <span class="nav-text">第四章 Schema 与数据类型优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#varchar-和-char"><span class="nav-number">4.1.</span> <span class="nav-text">varchar 和 char</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-enum-存储字符串类型"><span class="nav-number">4.2.</span> <span class="nav-text">使用 enum 存储字符串类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#timestamp-and-datetime"><span class="nav-number">4.3.</span> <span class="nav-text">timestamp and datetime</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bit"><span class="nav-number">4.4.</span> <span class="nav-text">bit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最后：建议"><span class="nav-number">4.5.</span> <span class="nav-text">最后：建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五章：高性能的索引"><span class="nav-number">5.</span> <span class="nav-text">第五章：高性能的索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引的类型"><span class="nav-number">5.1.</span> <span class="nav-text">索引的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#还能优化的手段"><span class="nav-number">5.2.</span> <span class="nav-text">还能优化的手段</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="NemoLaw" src="/images/author.jpg"><p class="site-author-name" itemprop="name">NemoLaw</p><div class="site-description" itemprop="description">但盼风雨来，能留你在此</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">250</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:nemo-lxg@outlook.com" title="E-Mail → mailto:nemo-lxg@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a> </span><span class="links-of-author-item"><a href="/archives/" title="archives → &#x2F;archives&#x2F;"><i class="fas fa-file-archive fa-fw"></i>archives</a> </span><span class="links-of-author-item"><a href="/categories/" title="categories → &#x2F;categories&#x2F;"><i class="fas fa-th fa-fw"></i>categories</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="heart"></i> </span><span class="author" itemprop="copyrightHolder">nemo-lxg@outlook.com</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">565k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">8:34</span></div><script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "eafd7ba3dbda4f7a8bc9b6c0b096c5fb", "spa": true}'></script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://nemolaw.com/2018/01/23/mysql_hignperformancemysql/',]
      });
      });</script><script>function loadCount(){var d=document,n=d.createElement("script");n.src="https://luoxugeng12581.disqus.com/count.js",n.id="dsq-count-scr",(d.head||d.body).appendChild(n)}window.addEventListener("load",loadCount,!1)</script><script>var disqus_config = function() {
    this.page.url = "https://nemolaw.com/2018/01/23/mysql_hignperformancemysql/";
    this.page.identifier = "2018/01/23/mysql_hignperformancemysql/";
    this.page.title = "Mysql 笔记：高性能 mysql 笔记 (上)";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://luoxugeng12581.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });</script></body></html>