<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <style>
  html {
    scroll-behavior: smooth;
  }
  body {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    margin: 30px auto 0 auto;
    padding: 10px;
  }
  body[data-mode="light"] {
    color: #2B2B2B;
    background-color: #EBEBEB;
  }
  body[data-mode="dark"] {
    color: #D8D8D8;
    background-color: #464646;
  }
  body[data-mode="sepia"] {
    color: #2B2B2B;
    background-color: #E7E2D5;
  }
  body[data-mode="black"] {
    color: #ACACAC;
    background-color: #121212;
  }
  body[data-loaded=true] {
    transition: color 0.4s, background-color 0.4s;
    margin-top: 56px;
  }
  body[data-images=false] img {
    display: none;
  }
  img {
    max-width: 100%;
    height: auto;
  }
  body[data-links=false] #reader-domain {
    display: none;
  }
  #reader-domain {
    font-size: 0.9em;
    line-height: 1.48em;
    padding-bottom: 4px;
    font-family: Helvetica, Arial, sans-serif;
    text-decoration: none;
    border-bottom-color: currentcolor;
    color: #0095dd;
  }
  #reader-title {
    font-size: 1.6em;
    line-height: 1.25em;
    width: 100%;
    margin: 20px 0;
    padding: 0;
  }
  #reader-credits {
    font-size: 0.9em;
    line-height: 1.48em;
    margin: 0 0 10px 0;
    padding: 0;
    font-style: italic;
  }
  #reader-estimated-time {
    font-size: 0.85em;
    line-height: 1.48em;
    margin: 0 0 10px 0;
    padding: 0;
  }
  #reader-credits:empty {
    disply: none;
  }
  </style>
</head>
<body data-images="true" data-links="true" data-mode="sepia" data-font="sans-serif" data-loaded="true">
  <span></span> <!-- for IntersectionObserver -->
  <a id="reader-domain" href="https://blog.codingnow.com/2011/05/bitcoin.html">blog.codingnow.com</a>
  <h1 dir="auto" id="reader-title">云风的 BLOG: Bitcoin 的基本原理</h1>
  <div dir="auto" id="reader-credits"></div>
  <div dir="auto" id="reader-estimated-time">5-6 minutes</div>
  <hr>
  <div id="readability-page-1" class="page"><div>
                              <p>昨天读到了 <a href="http://www.36kr.com/dangerous-bitcoin-p2p-currency/">Bitcoin</a> 的中文介绍，觉得非常有意思。不过上面这篇文章解释的非常不靠谱，我花了一晚上去<a href="http://www.bitcoin.org/">Bitcoin的官方网站</a> 仔细研究了一下，总算理解了其原理。感觉非常有启发，尤其是对虚拟货币的流通和发行有许多借鉴意义。今天写这篇 Blog 理一下。</p>

<p>什么是货币呢？货币就是商品(包括服务)交换的媒介。现在我们通行的货币是由有信誉的银行发行的，基本上是由其信誉来担保的。只要用的人都认可，那么我们就可以用它来交易。货币有一定的保值特性，我把我的劳动/服务/所有的商品换成货币后，银行担保我在日后的某一天，我还可以用它交换会差不多等值的东西。这个保证的前提是，银行不会滥发新的货币以及大家都信任这一点。</p>

                           </div><div id="more">
                              <p>以前，我们用贵金属做货币。因为贵金属产量不高，货币新增加的速度有限，而经济体在不断增大，市场需要更多的货币来让商品尽量的流通。有需求就有价值，从这个意义上来说，贵金属本身制造别的东西具备的价值是次要的，经济体需要货币来流通商品这个需求才是主要的。而贵金属产量有限，且曾经流通着的贵金属货币由于各种原因会退出市场，那么即使是新造的贵金属货币也有同样甚至更高的价值。</p>

<p>Bitcoin 为什么保值，BTC (Bitcoin 的货币简称）存在于一个庞大的 p2p 网络中。使用 Bitcoin 的群体公认了一种算法，这种算法在现今的条件下，每小时只会新产生大约 6 组新的 BTC ，目前一组是 50 个。也就是说，这个世界上，每个小时大约只会产生 300 个 BTC 。这个产量还会由网络自动调整难度来限制产量。你没办法通过修改所有人的 Client 的算法及参数（client 是开源的）来加快货币产量。伪造的货币会被网络丢弃（除非你可以控制大部分网络节点）。</p>

<p>BTC 本身有什么价值？</p>

<p>BTC 的价值就是交易渠道本身。一组新制造出来的 BTC 提供了把旧的 BTC 从一个帐户转移到另一个帐户的数学保证。这个安全保证背后的代价是大量的计算力。生产这么一个安全通道是需要消耗大量能源的，所以整个 BTC 用户群体，奖励那个造币者（目前是 50 BTC)。</p>

<p>简单说，我的理解就是，现在世界上所有的 BTC 背后都是用运行计算机的能量产生出来的，它们的总价值，（到现在一共有大约 12w 组 BTC 被生产出来，每组 50 个，市场价格大约 7.3 美金一个），应该是少于消耗掉的能源的总市场价值的。不过我想，用于生产 BTC 的能源大都原本就是不用也被浪费掉的资源。</p>

<hr>

<p>一个没有中心节点的“银行”是怎么让大家信任并工作起来的呢？</p>

<p>答案是，这个 p2p 网络上每个节点都记录了 BTC 诞生以来的每笔交易的详单，并从中可以推测出每个 BTC 唯一的属于谁。这样你接受一笔交易时，就能知道别人给你的钱是不是合法的。</p>

<p>从最基本的说起：</p>

<p>每个帐户其实就是一对公私匙，有私匙的人就是帐户的主人。如果 A 要给 B 转一笔钱，A 就把钱的数量加上 B 的公匙，用自己的钥匙签名。而 B 看到这个签名，就可以了解，的确是 A 转给了他如数的 BTC 。</p>

<p>那么这笔交易需要一个见证人，担保交易发生过。这样，以后 B 想用这笔钱的时候才是合法的。担保人就是整个使用 BTC 的网络。</p>

<p>A 在发起这笔交易的时候，必须把签过名的交易单尽量的广播到 p2p 网络上，最终会让每个节点都知道这件事。B 从 p2p 网络上不断的收到别人的确认信息。当它收到足够多的确认信息后，就认为 A 的确发出了这条交易单。这以后，B 就可以自由使用这笔钱了。</p>

<p>当 B 使用 A 转给它的钱给 C 时，也会广播给足够多（最终所有人都收到）的人让他们担保。每个担保人只有确信 B 有足够多的钱可以支付的时候才做确认。本质上，BTC 网络并没有记录每一块钱属于谁，它记录的是从诞生起到当前的每一笔交易，并推算出每个帐户里有多少钱。任何人试图确认一个交易单时，它需要确认的是转出帐号上有没有那么多钱。</p>

<p>Bitcoin 需要解决的核心问题是，如何避免一笔钱被花两次。</p>

<p>整个帐单序列是一环套一环的。每个人在完整的全局帐单上签上新的一笔的时候，都需要利用前面信息生成后面的。这个帐单序列被称为 chain of blocks 。每个 block 里面包含有若干条经过确认并 hash 签名 (难以伪造) 的交易记录。每个 block 都和全局表上的上一个 block 有关联。每条帐单都会通过 p2p 网络最终被转发给制造新 block 的节点上。</p>

<p>这个制造新 block 的过程被叫做 mining ，制造新 block 就是把最近收到的帐单打包在刚制造的 block 里。这个打包的过程即制作的过程，只有极其稀少的几率被制造成功。（你可以理解成把新收到的帐单合在一起，一次成型不可修改，如果制造失败就要再来一次）一旦制造成功，你就把新的 block （被认为是对老的全局 block 链的延续）广播出去。</p>

<p>因为是 p2p 网络，可能有许多人都在同时制造新的 block ，但有一个排序机制保证只有最优（最难，花费最大计算时间的）的那个新 block 被网络群体接受，挂在全局的 block 链上。重复一次，整个 BTC 网络只有一个全局帐单表，每个节点都完整的保存有一份。</p>

<p>这个全局帐单表会越来越大，block 链越来越长，在最新的部分，必然有许多分茬。这是因为 p2p 网络的 mining 过程是分开并行进行的，每条新帐单也不能立刻广播给所有的节点。每个 mining 的节点都有责任把他新收到的，在他认可的老的全局帐单上不存在的帐单，合在他准备制造的新 block 中。一旦新 block 被制造出来，就立刻广播出去，争取得到更多人的认可。主要是得到那些想 mining 的人的认可，这些人会在这个 block 的基础上制造新的 block 。</p>

<p>如果 p2p 网络过大，交易帐单不能尽量的迅速的广播到全网络。就会出来 p2p 的网络的局部保持有小群体共同认可的一份全局帐单。多个全局帐单的分支同时发展是有可能的。因为每个小群体都可能认为他们看见的那部分更长更有效。但是，只有有人发现另一条分支更长，它就会转换阵营。所以，有一定的可能性，你的帐单被一个小群体接受，但在一段时间后，被更大的阵营抛弃。</p>

<p>不过，算法参数决定了，新的 block 产生速度很慢，如果你的帐单被多达 6 个人确认，基本上就保证了它合并到的那份全局帐单，就是 p2p 网络全体认可的。</p>

<hr>

<p>既然生成新 block 费时费力，制造出新 block 的几率好象买彩票中大奖，还有那么多人去执行程序计算出新 block 呢？答案是，每个制造出新 block 的人，都有权利构造一条帐单声明老天给了我 50 BTC 。这个规则是被所有 BTC 用户共同承认的。把制造 block 等同于成挖金矿 (mining) 只是一个形象上的比喻。实际上，没有人可以把金子挖出来囤积。每个新 block 必须包含全局表上的上一个 block 的 hash 值，BTC 网络自我调节难度，让每 10 分钟大约产生一个新 block 。如果你 10 分钟内没制造出新的 block ，差不多就是说你前面 10 分钟干的活白干了。从最新版的 block 继续演算。</p>

<p>所以更恰当的比喻是买彩票。一个每 10 分钟开一次的彩票。你不停的花钱买，10 分钟内开中了就是你的，开不中先买的都作废，然后下一轮。</p>

<hr>

<p>数学上怎样保证 mining 的过程需要消耗大量的 CPU 时间？并只有很小的几率成功？</p>

<p>这里用到一个叫做 <a href="http://en.wikipedia.org/wiki/Hashcash">Hashcash</a> 的系统。它最早是为了改善 email spam 的问题被发明出来的。</p>

<p>就是给一段特定信息（比如这封 email 是从谁发给谁）加一个特定的 hash 头。这个 hash 头需要大量的 CPU 时间计算出来。发 spam 的人没有那么多 CPU 时间为群发的每一封 email 计算一个符合要求的 hash 头，所以认为有这个合法 hash 头的 email 不太可能是 spam （花了 CPU 时间在上面）</p>

<p>这个算法就是，为你想保护的信息，找到一串数字，附加上去后，使用某种公认的 hash 算法，比如 SHA-2 ，算出一个 hash 值。如果 hash 值由一长串 0 打头（具体多少个决定了难度），那么就成功了。</p>

<p>为一段信息，找到这串数字，在目前来说，除了暴力尝试没有什么好的方法。也就是随机更换数字，换一次就 hash 一次比对。在一个可以预期的尝试次数后，一般都能找到想找的数字。</p>

<p>每个想 mining 赚 BTC 的人，不停的从 BTC 网络上监听信息。如果有人发布了新的合法的 block ，他就合并到本地的全局表里。并重置自己的计算过程，从新得到的 block 开始。如果有新发布的交易单，也记录下来。不断的把最新的 block 的 hash 值、新收到的交易单，自己获得 50 BTC 的那条奖励单合并在一起，计算 SHA-256 ，看看结果是否满足条件。一旦满足，就把这个新的 block 广播出去。</p>

<p>当足够的人认可它，（以它为基础计算后面的 block ），他也就获得了那 50 BTC 。</p>

<hr>

<p>为了匹配 BTC 的经济规模。所有的 Bitcoin client 都被设置成，每 210000 个 block ，生产新 block 的人被认可凭空获得的 BTC 数量比之前的少一半（如果这个时候他还在包内写上自己获得 50 BTC ，其他人不会确认他的这个 block ）。这会让 BTC 的总量增速变缓。新的 block 产生的速度是由难度来调节的。这个难度会由 p2p 网络根据最近生产 block 的速度自动调节。所以即使日后计算能力增加，也能保证大约 10 分钟一个的速度。</p>

<p>而且，随着生产新 block 的收益减少，愿意贡献自己的 CPU 来 mining 的节点也会变少。（如果减少太多，只需要减少难度即可）</p>

<p>最终，p2p 网络不再凭空制造出新的 BTC ，这个时候制造新的 block 的动力是什么呢？那就是交易税。因为没有什么人愿意生产新的 block ，发起交易就变的困难。（没有 block 可以容纳交易单）希望交易被确认的人可以声明，如果有人制造出新的 block 接纳他的交易单，他会支付一小笔交易税给他。当许多人都这么做的时候，制造 block 又变的有利可图了。只不过，直接上不再有新的 BTC 诞生，只是在这些 BTC 用户之间流通。</p>

<p>总有一些 BTC 会消失，主要是那些帐号的私匙丢失了，没有任何人可以转移走帐户上的钱。不能流通的货币就不是货币了。但最终 BTC 总体会达到一个比较大的规模，准确说是两千一百万个。但 BTC 本身是可以切割的，比如你可以支付给别人 0.01 个 BTC 。所以 BTC 本身会升值，总数也一直够用。</p>

<hr>

<p>如果你觉得这篇文章对你有用，可以捐赠一点 BTC 给我玩玩。帐号是 1CDPtAPKf3EKLby85nnR35yBwPPsqHn8Cr</p>

<p><a href="https://freebitcoins.appspot.com/">这里有人免费派 BTC</a> ，每个 gmail 帐号给 0.02 BTC 。</p>

                           </div></div>
  <span></span> <!-- for IntersectionObserver -->

</body><style>@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;700&family=IBM+Plex+Serif:wght@400;500;700&family=Montserrat:wght@400;700&family=Zilla+Slab:wght@400;500&display=swap'); body {
      font-size:  22px;
      font-family: 'IBM Plex Sans', sans-serif;
      line-height: 28px;
      width: 850px;
    }</style><style>body {
  padding-bottom: 64px;
}
a:link, a:link:hover, a:link:active {
  color: #0095dd;
}
a:visited {
  color: #d33bf0;
}
a:link {
  text-decoration: none;
  font-weight: normal;
}
pre {
  white-space: pre-wrap;
}
pre code {
  background-color: #eff0f1;
  color: #393318;
  font-family: monospace;
  display: block;
  padding: 5px 10px;
}
body[data-mode="dark"] pre code {
  background-color: #585858;
  color: #e8e8e8;
}

/* CSS for sans-serif fonts */
body[data-font=sans-serif] {}
/* CSS for serif fonts */
body[data-font=serif] {}

/* CSS for "sepia" theme */
body[data-mode=sepia] {
}
/* CSS for "light" theme */
body[data-mode=light] {}
/* CSS for "dark" theme */
body[data-mode=dark] {}</style></html>